# FizzBuzz Tree
Practice with tree traversals and value access w/ FizzBuzz

## Challenge
Conduct “FizzBuzz” on a tree while traversing through it. Change the values of each of the nodes dependent on the current node’s value.

## Approach & Efficiency
1. Approach - This implementation traverses through a binary tree with pre-order traversals (evaluate the root first, then the left, then the right); during the traversal, it evaluates each node as its visited, and replaces its value with "Fizz", "Buzz", or "FizzBuzz" if the value can be evenly divided by 3, evenly divided by 5, or evenly divided by 15 respectively.

2. Efficiency - Big O Time = O(n) // Big O Space = O(h) (where h is the height of the tree) - In order to evaluate the value of each node, we must visit each node - each visit and evaluation loop is constant time (it's just a quick if/else tree), so overall time impact is O(n). We are traversing recursively through the tree, so each call adds another instance on the call stack (up to a height of h, the height of the tree); nothing new is generated by the traversal (we are replacing values in-place, not generating a tree), so the space required for the call stack dominates, resulting in an overall space impact of O(h).

## Solution

![Whiteboard for fizzBuzzTree](../../assets/fizzBuzzTree.jpg)

